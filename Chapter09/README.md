# 第９章 例外

--------------------------------------------------------------------------------------

# 57. 例外的状態にだけ例外を使用する

## 悪い例

```
try {
    int i = 0;
    while (true) {
        range[i++].climb();
    }
} catch(ArrayIndexOutOfBoundsException e) {
    // 正常
}
```

## 悪い理由

+ VMにとって例外処理は"重い"
+ try-catchブロック内の処理は最適化され難い事がある
+ 配列を順次処理するイディオムはVMに最適化されるのに対して、配列を例外で処理するイディオムは最適化されない

--------------------------------------------------------------------------------------

# 58. 回復可能な状態にはチェックされる例外を、プログラミングエラーには実行時例外を使用する

## 例外の種類

+ チェックされない例外 = 実行時例外(RuntimeException)とエラー(Error)
+ チェックされる例外 = 上記以外

## 使い分け

+ APIの呼び出し側が例外を検知して、別の処理を行うなど回復を試みることができる場合は、通常のExceptionを使う
+ APIの事前条件違反などのプログラミングミスでAPIを誤って使った場合に起きる例外は、RuntimeExceptionを使う

## 注意

+ 例外が発生した状態に関する情報を取得するために、文字列解析するのはクソ(項目10)
+ 例外の情報を提供するには、必要に応じたアクセサメソッドを提供するべき

--------------------------------------------------------------------------------------

# 59. チェックされる例外を不必要に使用するのを避ける

例外の発生を明示すること = APIを呼び出す側にとってコーディングの負担になる事を意識する

## 例外を明示できる条件

+ APIの適切な使用では例外を防ぐことができない かつ APIを使用しているプログラマが、例外に直面した時に何らかの有用な処理をできる場合

--------------------------------------------------------------------------------------

# 60. 標準例外を使用する

オレオレExceptionを無闇に定義することなかれ

## Java標準のExceptionを積極的に使うメリット

+ 学習コストが少なくて済む
+ 見慣れない例外でごちゃごちゃしないので、APIを使用するコードも読みやすくなる

## よく使われる例外

+ IllegalArgumetnException - メソッド呼び出しのパラメタが不適切
+ IllegalStateException - メソッド呼び出し前のオブジェクトの状態が不正
+ NullPointerException - パラメタにnullが禁止されているのに渡してきやがった
+ IndexOutOfBoudsException - インデックスパラメタが範囲外
+ ConcurrentModificationException - マルチスレッドでの使用が禁止されてるのに呼び出された
+ UnsupportedOperationException - オブジェクトがメソッドをサポートしていない。例えば、追加のみ可能なListで要素を削除しようとしたとか

--------------------------------------------------------------------------------------

# 61. 抽象概念に適した例外をスローする

上位レイヤは甲斐レベルの例外をキャッチして、上位レイヤの中で上位レベルの抽象概念の観点んから説明可能な例外をスローすべき(例外翻訳)

```
try {
    ...
} catch (LowerLevelException e) {
    throw new HigherLevelException(...);
}
```

+ API使用者に混乱を与えないための施策
+ 例外を発生させた原因をデバッグするために、例外連鎖(exception chaining)をするのが適切

```
try {
    ...
} catch (LowerLevelException cause) {
    throw new HigherLevelException(cause);
}

...

class HigherLevelException extends Exception {
    HigherLevelException(Throwable cause) {
        super(cause);
    }
}
```

+ ただし、濫用は禁物。可能であればそもそも下位レベルの例外が発生しないよう努めるべき

## 例外翻訳を使ってもいい条件

### 例外発生を防げない
+ 下位レイヤからの例外を防いだり、下位レイヤの例外から上位レイヤを隔離することが実現不能

### 例外翻訳しないと使用者が混乱する
+ 下位レベルのメソッドがフローするどれかの例外が、上位レイヤに対して不適切

--------------------------------------------------------------------------------------

# 62. 各メソッドがスローするすべての例外を文書化する

各例外がスローされる条件を、Javadocの@throwsタグで正確に文化書すること

+ 例外を文書化することで、メソッド呼び出しの事前条件を明記することになる
+ ある例外が同じ理由でクラス内の多くのメソッドでスローされる場合には、各メソッドではなく、クラスのdocにまとめて書くのはOK
+ 実行時例外、エラーについても同じく文書化すること

--------------------------------------------------------------------------------------

# 63. 詳細メッセージにエラー記録情報を含める

例外の文字列表現は、その例外の原因になったすべてのパラメータとフィールドの値を含んでいるべき。

例) ArrayIndexOutOfBoundsExceptionの詳細メッセージは、「下限範囲」「上限範囲」「範囲内に収まらなかった実際のインデックス」を含むべき

+ あくまでプログラマに分かる文言で書く。エンドユーザを意識する必要はない
+ コードでの回復を図るためには別途、例外の状態を取得するアクセサメソッドを用意する

--------------------------------------------------------------------------------------

# 64. エラーアトミック性に努める

# エラーアトミック性？

+ 呼び出しに失敗した場合、オブジェクトをそのメソッド呼び出し前の状態に戻す性質のこと

# どうやってエラーアトミック性を持たせるか

+ ミュータブルなオブジェクトを利用する(項目15)
+ パラメタチェックを厳密に行う(項目38)
+ リカバリコードを実装する(←大変)
+ Errorの場合には、エラーアトミック性を持たせる必要はない
+ エラーアトミック性を持たせない場合は、せめてAPIドキュメントにどのような状態に置かれるのか明記する

--------------------------------------------------------------------------------------

# 65. 例外を無視しない

## 例外が発生するには理由がある

+ API設計者がメソッドで例外が発生すると宣言している = 設計者が何かを伝えようとしている
+ 最低でも、catchブロックに例外を無視するのがなぜ適切かを説明するコメントを書くべき

--------------------------------------------------------------------------------------

EOF
